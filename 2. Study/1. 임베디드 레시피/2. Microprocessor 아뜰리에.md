# 1. Microprocessor 아뜰리에



### 1. Microprocessor 아뜰리에

- CPU 내부 작동 원리는 단순한 작업만 수행할 수 있게 되어 있어 생각보다 간단함
  - 데이터 전송
  - 연산
  - 분기 (Branch)
    - <u>위 작업들을 수행할 때, Interrupt 작업이 HW적으로 어떻게 이뤄지는지 알아봐야 함</u>



***

### 2. ARM Inside

> **[ARM Processor의 대표 특징]**
>
> 1. 32Bit RISC Processor
> 2. Big / Little Endian 지원
> 3. Fast Interrupt Response

- **Register Bank** : ARM Core에서 임시 저장공간을 담당
  - 32Bit 크기의 범용 Register 31개
  - Status Register 6개
    - 위 2가지가 묶여 있는 Register 묶음을 뜻함

- **Barrel Shifer** : 산술 연산을 시도할 때, 유용하게 사용 
  - Shift(왼쪽, 오른쪽) | Rotation(오른쪽)을 실행할 32Bit WORD와 Shift 수를 입력받음
    - Shift수만큼 Shift한 32Bit결과를 출력하는 특별한 회로

> ※ ARM이란, MCU의 CPU부분인 Core만을 의미
>
> ❓ **ARM이 저전력이면서, 고성능 Processor라고 불리는 이유**
>
> - RISC 구조를 사용하기 때문에 저전력 사용
>
>   - ARM - Advanced RISC Maachine
>
>   - 많이 사용되는 명령어, 데이터 형태, Addressing기법 등만을 모아 만든 Processor 이기에 저전력 사용
>
> - CISC 구조를 사용하면 많은 전력 사용
>
>   - 많은 수의 명령어, 데이터 형태, Addressing 기법들을 모두 채택
>   - 많은 기능들과 구조들이 포함되기에, Chip의 크기도 큼 (RISC 대비)



***

### 3. ARM mode와 Thumb mode

- Thumb mode는 ARM mode의 반쪽 Version이라고도 볼 수 있음
  - ARM은 32Bit RISC Machine이기에, 32Bit로 동작해야 최상의 Performance를 제공할 수 있음
    - word란, CPU가 한번에 처리할 수 있는 크기
      - ex) 8Bit Apple은 8Bit를 Word 단위로 하여, 8Bit씩 처리해야 최상의 Performance를 제공
- Thumb mode는 32Bit ARM에서 돌아가는 16Bit 기계어를 뜻함
  - ❓ **32Bit Machine에서 16Bit THUMB mode가 필요한 이유** : Business 때문
    - 처음 32Bit ARM을 만들었을 때, 메모리는 16Bit Data Line을 가지고 있었음
      - 그렇기에, ARM에서는 16Bit Data Line을 가진 메모리의 호환성을 높이기위해 만든 mode가 THUIMB mode로 출시



***

### 4. ARM 동작 Modes - 나는 어느 Mode 를 써야 하나

> ※ Mode를 작 익혀두어야, 여러가지 면에서 System을 Design 가능

###### 1. <u>Standard User Mode (Normal Mode)</u>

- **User(USR)** : Normal Program Execution Mode
  - Application Program을 Execution하는 Mode

###### 2. <u>Privileged Mode</u>

- **System(SYS)** : Run Privileged Operating System Tasks
  - Privileged Operating System(OS Level) Task가 실행되는 Mode
- **Fast Interrupt Requset(FIQ)** : When a High Priority (fast) Interrupt is Raised
  - SWI Instruction이 실행될 때, 사용되는 보호된 Operating System Mode
- **Interrupt Requset(IRQ)** : When a Low Priority (normal) Interrupt is Raised
- **Supervisor(SVC)** : A Protected Mode For The Operating System, Entered When a SWI Instruction is Executed
- **Abort(ABT)** : Used to Handle Memory Access Violations
- **Undef(UND)** : Used to Handle Undefined Instructions



##### ✏️ Mode는 사용자 취향에 따라 쓰고 싶은 Mode를 사용하면 됨

- Normal Mode와 Privileged Mode 구분
  1. Privileged Mode는 IRQ, FIQ 등의 Interrupt의 사용 가능 유무를 직접 설정할 수 있음
  2. Privileged Mode는 자기들끼리, 자기네들 스스로 서로 Mode 변경이 자유자재로 가능함
     - ✨Normal Mode에서 Privileged Mode로 전환은 불가능!

>  ※ ARM의 Default Mode는 Suervisor(SVC) Mode



***

### 5. ARM Register와 Context

> ARM Core를 잘 이해하기 위해서는 ARM Core에 내장되어 있는 기본 Register들이 어떻게 구성되어 있고, 어떻게 사용되는지 알면 상당히 좋음
>
> Thumb Mode와 ARM Mode간에 사용하는 Regiser의 갯수가 다르게 구성되어 있음

- **Register 종류** : Core가 사용할 수 있는 저장매체 중에 가장 빠른 속도를 가지고, ARM 동작은 Regiser들을 어떻게 다룰 것인지가 포인트!

  - ARM core는 동작 Mode가 변경되면, 사용하는 Regiser set도 변경됨

  - ARM core는 32Bit Register를 한 Mode당 R0~R15까지 16개하고, CPSR+SPSR까지 더해서 총 18개를 가짐

    - Bancked Register가 존재하여, Mode별로 사용하기에, 최소한의 Register를 가질 수 있게 해주는 저장 공간

  - Register의 개수는 총 37개가 존재

    - R0~R15 : 15개

    - CPSR : 1개

    - FIQ - R8~R14, SPSR : 8개

    - SVC - R13~R14, SPSR : 3개

    - ABT - R13~R14, SPSR : 3개

    - IRQ - R13~R14, SPSR : 3개

    - UND - R13~R14, SPSR : 3개

      - CPSR, PC, R0~R7 은 모든 Mode가 공용으로 사용

        ✨ **Mode가 변경되면 쓰이는 Regiser값도 변경됨! **

- **Regiser 역할**

  - CPSR (NZCV + Unused + IF + T + Mode)

    - Current Program Status Register
    - 무언가를 연산 한 후에 Set되는 Register

    1. NZCV

       - 이 Field는 방금 처리된 연산 결과의 상태를 나타냄

         - N (Negative) : 연산결과가 마이너스인 경우에 Set
         - Z (Zero) : 연산결과가 0인 경우에 Set
         - C (Carry) : 연산결과에 자리 올림이 발생한 경우에 Set
         - V (oVer Flow) : 연산결과가 OverFlow 났을 경우에 Set
         - Over Flow란, 원래 가져야 하는 Range보다 결과 값이 큰 경우를 뜻함

         - ARM Core는 Opcode를 Memory에서 가져오자마자 Fetch하지 않음
           - Condition Flag(NZCV)를 보고 바로 앞 Opcode를 실행할지 말지 결정

    2. IF

       - IRQ | FIQ가 걸릴 수 있는지에 관련된 Field

       - 7번째 Bit는 IRQ, 6번째 Bit는 FIQ Enable(0) / Disable(1)을 나타는 Field 

       - 이것으로 Interrupt가 걸리지 않도록 Control 가능

    3. Mode

       - Thumb Mode(16Bit) | ARM Mode(32Bit) 를 나타내는 Field

       - 0~4의 5개 Bit는 현재 Mode를 나타내서 SVC, UND 등을 나타냄

       - 현재 CPU 상태를 나타내기에, 매우 중요!

  - SPSR (Saved Program Status Regiser)

    - CPSR을 복사해 넣는 특수 Register
    - CPSR을 BackUp할 경우에 사용
      - SPSR에 CPSR의 값을 BackUp한 후 Mode를 바꾸게 되었을 때,
        SPSR에 있는 값을 CPSR에 써주게 되면 이전 상태로 바로 복귀!
        - 이런 특성으로, Privileged Mode에는 전부 SPSR Field가 존재

  - R13 (Stack Pointer)

    - 현재 Stack을 어디까지 쌓아 두었는지를 나타내주는 Field

  - R14 (Linked Register)
    - ARM은 어딘가로 Branch (Jump)를 할 때, 어디서 Branch 해 왔는지를 표시
    - 함수 호출 후 이전 위치로 돌아갈때 사용
  - R15 (Program Counter)
    - 현재 어디를 수행하고 있는건지를 나타내주는 Field
    - 실행하는 위치가 아닌 Fetch해 온 위치를 가리킴
  - R0~R12까지는 CPU의 동작 중에 저장 용도로 적절히 사용됨

- **Context 정의**

  - 문맥이라고 직역되나, 상황이라고 바라보면 개념을 이해하기 쉬움
  - Context Switching
    - 상황 전환, MCU의 현재 상황을 바꿈
  - Mode마다 구성된 Register 1Set를 나타내며, Register 정보를 통해 MCU의 상황을 바꿀 수 있음



***

### 6. ARM Exception 과 Modes

> Mode들은 어떻게 집입하는지 알아봐야함
>
> Privileged Mode는 자기 마음대로 바꿀 수 있지만, 그거 이외에 Hardware적으로 자동으로 특정 Mode에 진입할 수 있음!
>
> - 그런 Mode 진입 유발자가 바로 Exception
>
>   - Exception은 Interrupt를 포함한 더 큰 사건을 의미!
>   - Interrupt는 Exceptions의 한 종류
>   - Exception이라는 사건을 통해서 Hardware적으로 정해진 특별한 Reaction이 발생
>
> - Reaction이라는 것은 Exception이 발생하면 진행하던 동작을 멈추고, Exception의 종류에 해당하는 mode에 진입하고
>
>   그 Exception에 물려 있는 해당 주소로 pc를 jump시킨 후 Exception에 대한 처리를 함

- **Mode별 Exception 발생 항목**

  1. SVC Mode
     - ARM에 전원을 인가하거나, Reset을 시키면 SVC Mode로 진입하면서, PC를 0x0 (Low vector인 경우)로 Jump 시킴

  2. IRQ & FIQ Mode
     - Interrupt가 발생하면, IRQ 또는 FIQ Mode로 진입하면서, PC를 0x1C 또는 0x18로 jump 시킴

  3. ABORT Mode

     - Data abort가 난 경우에는 0x10으 jump 시키고 ABORT mode로 진입

     - Prefetch abort가 난 경우에는  0x0C로 jump 시키고 ABORT mode로 진입

  4. UNDEF Mode
     - Undef exception이 났을 경우에 UNDEF mode로 진입하면서 PC를 0x04로 jump 시킴

​	<u>※ PC를 어딘가로 jump 시킨다는 얘기는 PC값을 그값으로 Setting한다는 뜻! (Setting후 Software 실행)</u>



✏️   위와 같이 Exception이 일어났을 때 jump하는 Address들을 모아 작성한 것을 Exception Vector Table이라고 함

​	다시 말해, Exception이 발생하면 그 Exception에 해당하는 미리 정해진 Address의 프로그램을 하드웨어적으로 수행하는데,

​	이 Address를 Exception Vector라 하고, 각각의 Exception에 대해서 Exception Vector를 정의해놓은 테이블을 Exception Vector Table이라고 함

✨  Privileged mode에 의해서 User mode로 한번 가게 될 경우 Exception 없이는 다른 Priviledged mode로 돌아올 수 없음!



- **Exception들이 어떨 때 발생하는지?**

  1. SVC mode : Power On 또는 Reset이 발생한 경우 진입
  2. IRQ mode : Hareware적인 Interrupt가 발생하여 ARM Core에 알려주면 진입
  3. FIQ mode : Interrupt 중 Fast Interrupt가 발생하면 진입
  4. ABT mode : Access 하려는 주소가 Access 할 수 없는 주소이거나, Instrruction fetch를 해오려는데 못해 온 경우에 진입함
  5. UND mode : Instruction을 decode했는데 ARM이 모르는 것일 경우에 진입 (보통 Memory Corruption이 발생할 경우 진입)
     - 이걸 응용하면, ARM이 사용하지 않는 코드를 일부러 상입해두고 UND vector 주소로 jump하게 하여 디버깅 코드로 활용할 수 있음

  > ✏️ **Mode는 CPSR - Register 0 ~ 4의 값이 어떻게 Setting되느냐고 따라 결정된다는 것은 기억해야함!**
  >
  > CPSR - Register 값에 들어가 있는 값에 따라 사용되는 Register set과 STack이 바뀐다는 것을 의미



- **Exception 우선순위 : 시스템에 영향도에 따라 결정**
  1. Reset - SVC Mode
  2. Data Abort - ABT Mode
  3. FIQ - FIQ Mode
  4. IRQ - IRQ Mode
  5. Prefetch Abort - ABT Mode
  6. Undefined Instruction - UND Mode
  7. SWI - SVC Mode



- **Exception 발생 후 처리 과정**

  1. Exception Mode가 발생 한 후 이전 Mode로 돌아갈 수 있도록 준비
     - CPSR을 저장할 수 있어야 함 (현재 Mode가 어떤 Mode였는지에 대한 정보 저장)
  2. 지금 쓰던 Register 값들을 다시 사용할 수 있도록 준비 (이전에 쓰던 Context를 다시 복원할 수 있어야 함)
     - Context를 Stack에 저장 (Bacnked Register를 제외한 나머지 Regiter R0~R12 저장)
  3. 이전 Mode로 돌아갔을 때 원래 수행하던 일을 이어갈 수 있어야 함
     - 원래 수행하던 곳으로 이동하기 위한 주소값 저장
  4. 그리고 자동으로 해당 Exception Vector로 이동!
     - Exception이 발생한 곳으로 이동

  

- **SVC mode에서 동작하던 중 IRQ가 발생하게 될 경우**

  - Exception이 발생하여 CPSR의 mode를 IRQ로 변경

  - IRQ mode의 Banked Register인, R13_irq, R14_irq, SPSR_irq로 현재 Context가 Hardware적으로 자동으로 변경됨

    - Exception이 발생하면 무조건 32Bit ARM mode로 ARM state가 바뀜!

  - Interrupt 발생 시 주소 이동 순서

    1. CPSR을 SRPSR_irq에 복사

    2. CPSR의 mode를 IRQ로 변경, Stack Pointer도 IRQ mode의 Stack Pointer로 변경

    3. IRQ disable, ARM mode로 변경
       - IRQ disable 설정은 CPSR의 I bit를 1로 Setting
       - ARM mode 설정은 CPSR의 T bit를 0으로 Setting
    4. R14_irq := 현재 PC
    5. IRQ Exception Vector 주소인 0x18로 이동해야하기에 PC := 0x18로 설정
       - PC := 0x18 설정까지가 Hardware 처리, Software적으로는 0x18에 있는 IRQ handler를 처리
    6. R0~R12를 R13_irq (Stack Pointer)가 가리키는 stack에 저장
    7. 돌아갈 주소를 보정
       - R14_irq(LR) = PC에 넣었으니 interrupt가 걸린 순간에는 pipe line에 의해서 2개 opcode가 이미 진행됨
       - sub lr, lr, #4 처럼 lr을 보정해야만 돌아갈 주소로 돌아갈 수 있음 (어셈블리 단)

  - Interrupt 처리 후 주소 복귀 순서

    - CPSR := SPSR_irq를 넣으면 > 이전 mode SVC로 복귀
    - Stack에 저장했던 Register값들을 복원
    - PC := R14_irq를 넣으면 > SVC mode에서 처리하던 곳으로 복귀





